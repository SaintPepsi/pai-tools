/**
 * ============================================================================
 * ANALYZE — GitHub Integration
 * ============================================================================
 *
 * GitHub label management and issue construction for analyze recommendations.
 * Handles label existence checks, label creation, issue body assembly, and
 * issue creation via the `gh` CLI.
 *
 * ============================================================================
 */

import { log } from '../../shared/log.ts';
import type { AnalysisResult, IssueData } from './types.ts';

// ─── Label Definitions ───────────────────────────────────────────────────────

const LABEL_COLORS: Record<string, string> = {
	'refactor': '1d76db',
	'ai-suggested': 'c5def5',
	'priority:high': 'e11d48',
};

// ─── Label Management ────────────────────────────────────────────────────────

export async function ensureLabels(labels: string[], repoRoot: string): Promise<void> {
	for (const label of labels) {
		const check = Bun.spawnSync(['gh', 'label', 'list', '--search', label, '--json', 'name'], {
			cwd: repoRoot,
			stdout: 'pipe',
			stderr: 'pipe',
		});

		const output = new TextDecoder().decode(check.stdout as Buffer).trim();
		let exists = false;
		try {
			const parsed = JSON.parse(output) as { name: string }[];
			exists = parsed.some(l => l.name === label);
		} catch {}

		if (!exists) {
			const color = LABEL_COLORS[label] ?? 'ededed';
			const create = Bun.spawnSync(
				['gh', 'label', 'create', label, '--color', color, '--force'],
				{ cwd: repoRoot, stdout: 'pipe', stderr: 'pipe' }
			);
			if (create.exitCode === 0) {
				log.info(`Created missing label: ${label}`);
			} else {
				log.warn(`Could not create label '${label}' — issue creation may fail`);
			}
		}
	}
}

// ─── Issue Construction ──────────────────────────────────────────────────────

export function buildIssueData(result: AnalysisResult): IssueData | null {
	if (result.tier1.severity === 'ok' && !result.tier2) return null;

	const { tier1, tier2 } = result;
	const splitCount = tier2?.suggestions?.length ?? 0;

	const title = splitCount > 0
		? `refactor(${tier1.relativePath}): split into ${splitCount} focused modules`
		: `refactor(${tier1.relativePath}): decompose file (${tier1.lineCount} lines)`;

	let body = `## File Structure Analysis\n\n`;
	body += `**File:** \`${tier1.relativePath}\`\n`;
	body += `**Language:** ${tier1.language}\n`;
	body += `**Lines:** ${tier1.lineCount} (soft: ${tier1.softThreshold}, hard: ${tier1.hardThreshold})\n`;
	body += `**Severity:** ${tier1.severity}\n\n`;

	body += `### Heuristic Signals\n\n`;
	for (const signal of tier1.signals) {
		body += `- ${signal}\n`;
	}

	if (tier2) {
		body += `\n### Detected Responsibilities\n\n`;
		for (const r of tier2.responsibilities) {
			body += `- **${r.name}**: ${r.description} (lines ${r.lineRanges})\n`;
		}

		if (tier2.suggestions.length > 0) {
			body += `\n### Suggested Split\n\n`;
			for (const s of tier2.suggestions) {
				body += `- \`${s.filename}\` — ${s.responsibilities.join(', ')}\n`;
				body += `  - _${s.rationale}_\n`;
			}
		}

		if (tier2.principles.length > 0) {
			body += `\n### Principle Violations\n\n`;
			for (const p of tier2.principles) {
				body += `- ${p}\n`;
			}
		}

		body += `\n### Effort: ${tier2.effort}\n\n`;
		body += `${tier2.summary}\n`;

		// Acceptance criteria from Tier 2 analysis
		body += `\n### Acceptance Criteria\n\n`;
		if (tier2.suggestions.length > 0) {
			for (const s of tier2.suggestions) {
				body += `- [ ] \`${s.filename}\` created with ${s.responsibilities.join(', ')} responsibility\n`;
			}
		}
		body += `- [ ] All existing exports re-exported or migrated (no broken imports)\n`;
		body += `- [ ] Original file removed or reduced to re-exports only\n`;
		body += `- [ ] No resulting file exceeds ${tier1.softThreshold} lines (soft threshold)\n`;
		body += `- [ ] Tests pass\n`;
	} else {
		// No Tier 2 data — flag for manual scoping
		body += `\n> **Note:** This issue was generated from heuristic signals only (no AI analysis). `;
		body += `It may need manual scoping or a \`pait analyze --budget\` re-run before automated implementation.\n`;

		body += `\n### Acceptance Criteria\n\n`;
		body += `- [ ] File decomposed into focused modules with single responsibilities\n`;
		body += `- [ ] All existing exports re-exported or migrated (no broken imports)\n`;
		body += `- [ ] No resulting file exceeds ${tier1.softThreshold} lines (soft threshold)\n`;
		body += `- [ ] Tests pass\n`;
	}

	body += `\n---\n_Generated by \`pait analyze\`_\n`;

	const labels = ['refactor', 'ai-suggested'];
	if (tier1.severity === 'critical') labels.push('priority:high');

	return { title, body, labels, relativePath: tier1.relativePath };
}

// ─── Duplicate Detection ──────────────────────────────────────────────────────

/**
 * Check whether an open issue already exists targeting the given file path.
 * Searches for issues with a title matching `refactor({relativePath})`.
 * Returns the existing issue number if found, null otherwise.
 */
export function findExistingIssue(relativePath: string, repoRoot: string): number | null {
	const searchQuery = `refactor(${relativePath})`;
	const check = Bun.spawnSync(
		['gh', 'issue', 'list', '--search', searchQuery, '--state', 'open', '--json', 'number,title'],
		{
			cwd: repoRoot,
			stdout: 'pipe',
			stderr: 'pipe',
		}
	);

	const output = new TextDecoder().decode(check.stdout as Buffer).trim();
	try {
		const issues = JSON.parse(output) as { number: number; title: string }[];
		const match = issues.find(i => i.title.startsWith(`refactor(${relativePath})`));
		return match ? match.number : null;
	} catch {
		return null;
	}
}

// ─── Issue Creation ──────────────────────────────────────────────────────────

/**
 * Create a GitHub issue, skipping if a duplicate already exists for the same file.
 * Returns the new issue URL on success, null on skip or failure.
 */
export async function createGitHubIssue(
	issue: IssueData,
	repoRoot: string,
	dryRun: boolean,
): Promise<string | null> {
	// Build the full body, prepending dependency markers if needed
	let body = issue.body;
	if (issue.dependsOn && issue.dependsOn.length > 0) {
		const depList = issue.dependsOn.map(n => `#${n}`).join(', ');
		body = `> **Depends on:** ${depList}\n\n${body}`;
	}

	// Dry-run guard: return early before any network calls (including dedup check).
	if (dryRun) {
		const depStr = issue.dependsOn?.length ? ` (depends on: ${issue.dependsOn.map(n => `#${n}`).join(', ')})` : '';
		log.info(`[DRY RUN] Would create: ${issue.title}${depStr}`);
		return null;
	}

	// Deduplication check: skip if an open issue already targets this file.
	// Only runs outside dry-run to avoid unnecessary network calls during previews.
	if (issue.relativePath) {
		const existingNumber = findExistingIssue(issue.relativePath, repoRoot);
		if (existingNumber !== null) {
			log.info(`Skipping ${issue.relativePath} — open issue #${existingNumber} already exists`);
			return null;
		}
	}

	const labelArgs = issue.labels.flatMap(l => ['--label', l]);

	const proc = Bun.spawn(
		['gh', 'issue', 'create', '--title', issue.title, '--body', body, ...labelArgs],
		{
			cwd: repoRoot,
			stdout: 'pipe',
			stderr: 'pipe',
		}
	);

	const output = await new Response(proc.stdout).text();
	const exitCode = await proc.exited;

	if (exitCode !== 0) {
		const stderr = await new Response(proc.stderr).text();
		log.warn(`Failed to create issue: ${stderr.trim()}`);
		return null;
	}

	return output.trim();
}

/**
 * Parse an issue number from a GitHub issue URL.
 * e.g. "https://github.com/owner/repo/issues/42" → 42
 */
export function parseIssueNumber(url: string): number | null {
	const match = url.match(/\/issues\/(\d+)/);
	return match ? parseInt(match[1], 10) : null;
}

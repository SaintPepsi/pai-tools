/**
 * ============================================================================
 * ANALYZE — GitHub Integration
 * ============================================================================
 *
 * GitHub label management and issue construction for analyze recommendations.
 * Handles label existence checks, label creation, issue body assembly, and
 * issue creation via the `gh` CLI.
 *
 * ============================================================================
 */

import { log } from '../../shared/log.ts';
import type { AnalysisResult, IssueData } from './types.ts';

// ─── Label Definitions ───────────────────────────────────────────────────────

const LABEL_COLORS: Record<string, string> = {
	'refactor': '1d76db',
	'ai-suggested': 'c5def5',
	'priority:high': 'e11d48',
};

// ─── Label Management ────────────────────────────────────────────────────────

export async function ensureLabels(labels: string[], repoRoot: string): Promise<void> {
	for (const label of labels) {
		const check = Bun.spawnSync(['gh', 'label', 'list', '--search', label, '--json', 'name'], {
			cwd: repoRoot,
			stdout: 'pipe',
			stderr: 'pipe',
		});

		const output = new TextDecoder().decode(check.stdout as Buffer).trim();
		let exists = false;
		try {
			const parsed = JSON.parse(output) as { name: string }[];
			exists = parsed.some(l => l.name === label);
		} catch {}

		if (!exists) {
			const color = LABEL_COLORS[label] ?? 'ededed';
			const create = Bun.spawnSync(
				['gh', 'label', 'create', label, '--color', color, '--force'],
				{ cwd: repoRoot, stdout: 'pipe', stderr: 'pipe' }
			);
			if (create.exitCode === 0) {
				log.info(`Created missing label: ${label}`);
			} else {
				log.warn(`Could not create label '${label}' — issue creation may fail`);
			}
		}
	}
}

// ─── Issue Construction ──────────────────────────────────────────────────────

export function buildIssueData(result: AnalysisResult): IssueData | null {
	if (result.tier1.severity === 'ok' && !result.tier2) return null;

	const { tier1, tier2 } = result;
	const splitCount = tier2?.suggestions?.length ?? 0;

	const title = splitCount > 0
		? `refactor(${tier1.relativePath}): split into ${splitCount} focused modules`
		: `refactor(${tier1.relativePath}): decompose file (${tier1.lineCount} lines)`;

	let body = `## File Structure Analysis\n\n`;
	body += `**File:** \`${tier1.relativePath}\`\n`;
	body += `**Language:** ${tier1.language}\n`;
	body += `**Lines:** ${tier1.lineCount} (soft: ${tier1.softThreshold}, hard: ${tier1.hardThreshold})\n`;
	body += `**Severity:** ${tier1.severity}\n\n`;

	body += `### Heuristic Signals\n\n`;
	for (const signal of tier1.signals) {
		body += `- ${signal}\n`;
	}

	if (tier2) {
		body += `\n### Detected Responsibilities\n\n`;
		for (const r of tier2.responsibilities) {
			body += `- **${r.name}**: ${r.description} (lines ${r.lineRanges})\n`;
		}

		if (tier2.suggestions.length > 0) {
			body += `\n### Suggested Split\n\n`;
			for (const s of tier2.suggestions) {
				body += `- \`${s.filename}\` — ${s.responsibilities.join(', ')}\n`;
				body += `  - _${s.rationale}_\n`;
			}
		}

		if (tier2.principles.length > 0) {
			body += `\n### Principle Violations\n\n`;
			for (const p of tier2.principles) {
				body += `- ${p}\n`;
			}
		}

		body += `\n### Effort: ${tier2.effort}\n\n`;
		body += `${tier2.summary}\n`;

		// Acceptance criteria from Tier 2 analysis
		body += `\n### Acceptance Criteria\n\n`;
		if (tier2.suggestions.length > 0) {
			for (const s of tier2.suggestions) {
				body += `- [ ] \`${s.filename}\` created with ${s.responsibilities.join(', ')} responsibility\n`;
			}
		}
		body += `- [ ] All existing exports re-exported or migrated (no broken imports)\n`;
		body += `- [ ] Original file removed or reduced to re-exports only\n`;
		body += `- [ ] No resulting file exceeds ${tier1.softThreshold} lines (soft threshold)\n`;
		body += `- [ ] Tests pass\n`;
	} else {
		// No Tier 2 data — flag for manual scoping
		body += `\n> **Note:** This issue was generated from heuristic signals only (no AI analysis). `;
		body += `It may need manual scoping or a \`pait analyze --budget\` re-run before automated implementation.\n`;

		body += `\n### Acceptance Criteria\n\n`;
		body += `- [ ] File decomposed into focused modules with single responsibilities\n`;
		body += `- [ ] All existing exports re-exported or migrated (no broken imports)\n`;
		body += `- [ ] No resulting file exceeds ${tier1.softThreshold} lines (soft threshold)\n`;
		body += `- [ ] Tests pass\n`;
	}

	body += `\n---\n_Generated by \`pait analyze\`_\n`;

	const labels = ['refactor', 'ai-suggested'];
	if (tier1.severity === 'critical') labels.push('priority:high');

	return { title, body, labels };
}

// ─── Issue Creation ──────────────────────────────────────────────────────────

export async function createGitHubIssue(issue: IssueData, repoRoot: string, dryRun: boolean): Promise<string | null> {
	if (dryRun) {
		log.info(`[DRY RUN] Would create: ${issue.title}`);
		return null;
	}

	const labelArgs = issue.labels.flatMap(l => ['--label', l]);

	const proc = Bun.spawn(
		['gh', 'issue', 'create', '--title', issue.title, '--body', issue.body, ...labelArgs],
		{
			cwd: repoRoot,
			stdout: 'pipe',
			stderr: 'pipe',
		}
	);

	const output = await new Response(proc.stdout).text();
	const exitCode = await proc.exited;

	if (exitCode !== 0) {
		const stderr = await new Response(proc.stderr).text();
		log.warn(`Failed to create issue: ${stderr.trim()}`);
		return null;
	}

	return output.trim();
}

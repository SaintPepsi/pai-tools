/**
 * ============================================================================
 * ANALYZE — Issue Formatter
 * ============================================================================
 *
 * Pure data transformation: converts an AnalysisResult into the structured
 * IssueData shape used for GitHub issue creation.
 *
 * ============================================================================
 */

import type { AnalysisResult, IssueData } from './types.ts';

// ─── Issue Construction ──────────────────────────────────────────────────────

export function buildIssueData(result: AnalysisResult): IssueData | null {
	if (result.tier1.severity === 'ok' && !result.tier2) return null;

	const { tier1, tier2 } = result;
	const splitCount = tier2?.suggestions?.length ?? 0;

	const title = splitCount > 0
		? `refactor(${tier1.relativePath}): split into ${splitCount} focused modules`
		: `refactor(${tier1.relativePath}): decompose file (${tier1.lineCount} lines)`;

	let body = `## File Structure Analysis\n\n`;
	body += `**File:** \`${tier1.relativePath}\`\n`;
	body += `**Language:** ${tier1.language}\n`;
	body += `**Lines:** ${tier1.lineCount} (soft: ${tier1.softThreshold}, hard: ${tier1.hardThreshold})\n`;
	body += `**Severity:** ${tier1.severity}\n\n`;

	body += `### Heuristic Signals\n\n`;
	for (const signal of tier1.signals) {
		body += `- ${signal}\n`;
	}

	if (tier2) {
		body += `\n### Detected Responsibilities\n\n`;
		for (const r of tier2.responsibilities) {
			body += `- **${r.name}**: ${r.description} (lines ${r.lineRanges})\n`;
		}

		if (tier2.suggestions.length > 0) {
			body += `\n### Suggested Split\n\n`;
			for (const s of tier2.suggestions) {
				body += `- \`${s.filename}\` — ${s.responsibilities.join(', ')}\n`;
				body += `  - _${s.rationale}_\n`;
			}
		}

		if (tier2.principles.length > 0) {
			body += `\n### Principle Violations\n\n`;
			for (const p of tier2.principles) {
				body += `- ${p}\n`;
			}
		}

		body += `\n### Effort: ${tier2.effort}\n\n`;
		body += `${tier2.summary}\n`;

		// Acceptance criteria from Tier 2 analysis
		body += `\n### Acceptance Criteria\n\n`;
		if (tier2.suggestions.length > 0) {
			for (const s of tier2.suggestions) {
				body += `- [ ] \`${s.filename}\` created with ${s.responsibilities.join(', ')} responsibility\n`;
			}
		}
		body += `- [ ] All existing exports re-exported or migrated (no broken imports)\n`;
		body += `- [ ] Original file removed or reduced to re-exports only\n`;
		body += `- [ ] No resulting file exceeds ${tier1.softThreshold} lines (soft threshold)\n`;
		body += `- [ ] Tests pass\n`;
	} else {
		// No Tier 2 data — flag for manual scoping
		body += `\n> **Note:** This issue was generated from heuristic signals only (no AI analysis). `;
		body += `It may need manual scoping or a \`pait analyze --budget\` re-run before automated implementation.\n`;

		body += `\n### Acceptance Criteria\n\n`;
		body += `- [ ] File decomposed into focused modules with single responsibilities\n`;
		body += `- [ ] All existing exports re-exported or migrated (no broken imports)\n`;
		body += `- [ ] No resulting file exceeds ${tier1.softThreshold} lines (soft threshold)\n`;
		body += `- [ ] Tests pass\n`;
	}

	body += `\n---\n_Generated by \`pait analyze\`_\n`;

	const labels = ['refactor', 'ai-suggested'];
	if (tier1.severity === 'critical') labels.push('priority:high');

	return { title, body, labels, relativePath: tier1.relativePath };
}
